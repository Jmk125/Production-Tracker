<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Project Comparison - Production Tracker</title>
  <link rel="stylesheet" href="/style.css">
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0"></script>
</head>
<body>
  <header>
    <div class="container">
      <h1>üèóÔ∏è Production Tracker</h1>
      <nav>
        <a href="/">Projects</a>
        <a href="/comparison" class="active">Comparison</a>
      </nav>
    </div>
  </header>

  <div class="container">
    <div class="card" style="margin-bottom: 1.5rem;">
      <h2 style="margin-bottom: 1rem;">Project Comparison</h2>
      <p style="color: var(--text-secondary);">
        Select multiple projects to compare their labor hours and productivity metrics
      </p>
    </div>

    <div class="grid" style="grid-template-columns: 300px 1fr; gap: 1.5rem; align-items: start;">
      <!-- Project Selector -->
      <div class="card">
        <h3 class="card-title" style="margin-bottom: 1rem;">Select Projects</h3>
        <div id="projectCheckboxes" class="checkbox-group">
          <p style="color: var(--text-secondary); text-align: center; padding: 1rem;">
            Loading projects...
          </p>
        </div>
        <button class="btn btn-primary" style="width: 100%; margin-top: 1rem;" onclick="loadComparison()">
          Compare Selected
        </button>
      </div>

      <!-- Comparison View -->
      <div>
        <div class="card" style="margin-bottom: 1.5rem;">
            <div class="card-header">
              <h3 class="card-title">Timeline Comparison</h3>
            <div class="timeline-control-group" style="display: flex; gap: 1rem; flex-wrap: wrap; justify-content: flex-end; align-items: center;">
              <select id="timelineType" onchange="updateCharts()">
                <option value="project">Project Timeline (Month 1, 2, 3...)</option>
                <option value="calendar">Calendar Timeline</option>
              </select>
              <select id="comparisonView" onchange="updateCharts()">
                <option value="total">Total Hours</option>
                <option value="costCode">By Cost Code</option>
                <option value="costCodeDivision">By Cost Code Division</option>
                <option value="payClass">By Pay Class</option>
                <option value="job">By Job/Building</option>
                <option value="division09">09 Package (Division 09 only)</option>
                <option value="package06Combo">06 Package (Div 06, 08, 10, 11, 12)</option>
                <option value="packageComparison">Packages: 09 vs 06/08/10/11/12</option>
              </select>
              <div class="chart-controls" style="display: flex; gap: 0.75rem; align-items: center; flex-wrap: wrap;">
                <label class="checkbox" style="margin: 0;">
                  <input type="checkbox" id="showAverageCurvesToggle" onchange="updateCharts()">
                  Show average curves
                </label>
                <select id="averageCurveMode" onchange="updateCharts()">
                  <option value="actual">Show actual only</option>
                  <option value="average">Average curves</option>
                  <option value="overlay" selected>Actual with average overlay</option>
                </select>
                <select id="comparisonView" onchange="updateCharts()">
                  <option value="total">Total Hours</option>
                  <option value="costCode">By Cost Code</option>
                  <option value="costCodeDivision">By Cost Code Division</option>
                  <option value="payClass">By Pay Class</option>
                  <option value="job">By Job/Building</option>
                  <option value="division09">09 Package (Division 09 only)</option>
                  <option value="package06Combo">06 Package (Div 06, 08, 10, 11, 12)</option>
                  <option value="packageComparison">Packages: 09 vs 06/08/10/11/12</option>
                </select>
                <div class="chart-controls" style="display: flex; gap: 0.75rem; align-items: center; flex-wrap: wrap;">
                  <label class="checkbox" style="margin: 0;">
                    <input type="checkbox" id="showAverageCurvesToggle" onchange="updateCharts()">
                    Show average curves
                  </label>
                  <select id="averageCurveMode" onchange="updateCharts()">
                    <option value="actual">Show actual only</option>
                    <option value="average">Average curves</option>
                    <option value="overlay" selected>Actual with average overlay</option>
                  </select>
                  <label class="checkbox" style="margin: 0;">
                    <input type="checkbox" id="combinedAverageToggle" checked onchange="updateCharts()">
                    Include combined average
                  </label>
                </div>
              </div>
            </div>
          </div>
          <div id="comparisonFilterPanel" class="filter-bar" style="display: none;">
            <div class="filter-section">
              <div class="filter-section-header">
                <div>
                  <div class="filter-title">Cost codes</div>
                  <div class="filter-subtitle">Choose which cost codes feed the charts</div>
                </div>
                <button class="collapse-toggle" type="button" onclick="toggleFilterSection('comparisonCostCodeSection', this)">Hide</button>
              </div>
              <div id="comparisonCostCodeSection" class="filter-section-body">
                <div class="filter-actions">
                  <label class="checkbox">
                    <input type="checkbox" id="comparisonCostCodeAllToggle" checked onchange="toggleAllCostCodes(event)"> All cost codes
                  </label>
                  <label class="checkbox">
                    <input type="checkbox" id="comparisonCostCode09Toggle" checked onchange="toggleDivisionCostCodes(event, ['09'])"> 09 division
                  </label>
                  <label class="checkbox">
                    <input type="checkbox" id="comparisonCostCode06GroupToggle" checked onchange="toggleDivisionCostCodes(event, ['06','08','10','11','12'])"> 06 + 08/10/11/12 divisions
                  </label>
                </div>
                <div id="comparisonCostCodeList" class="filter-list"></div>
              </div>
            </div>
          </div>
          <div class="chart-container">
            <canvas id="comparisonChart"></canvas>
          </div>
        </div>

        <div class="card" style="margin-bottom: 1.5rem;">
          <div class="card-header" style="align-items: flex-start;">
            <div>
                <h3 class="card-title">Monthly Employees</h3>
                <div id="employeeComparisonSubtitle" style="color: var(--text-secondary); font-size: 0.9rem;">Unique employees working each month</div>
              </div>
              <div class="chart-controls">
                <label for="employeeComparisonMetric" style="font-size: 0.9rem; color: var(--text-secondary);">View</label>
                <select id="employeeComparisonMetric" onchange="updateEmployeeChart(getFilteredComparisonData())">
                  <option value="unique" selected>Unique employees</option>
                  <option value="average">Average daily crew size</option>
                </select>
              </div>
            </div>
          <div class="chart-container" style="min-height: 360px;">
            <canvas id="employeeComparisonChart"></canvas>
          </div>
        </div>

        <div class="card" id="costCodeVarianceCard" style="margin-bottom: 1.5rem; display: none;">
          <div class="card-header" style="align-items: flex-start;">
            <div>
              <h3 class="card-title">Cost Code Variance</h3>
              <div style="color: var(--text-secondary); font-size: 0.9rem;">Spent vs. budgeted hours by cost code</div>
            </div>
            <div style="display: flex; gap: 1rem; align-items: center; flex-wrap: wrap; justify-content: flex-end;">
              <button class="btn btn-secondary" onclick="openCodeMappingModal()" style="font-size: 0.875rem;">
                Manage Code Mappings
              </button>
              <label class="checkbox" style="margin: 0; display: flex; align-items: center; gap: 0.35rem;">
                <input type="checkbox" id="showVarianceAverageBar" onchange="renderCostCodeVarianceChart(getFilteredComparisonData())">
                Show average bar
              </label>
              <label class="checkbox" style="margin: 0; display: flex; align-items: center; gap: 0.35rem;">
                <input type="checkbox" id="varianceAverageOnlyToggle" onchange="renderCostCodeVarianceChart(getFilteredComparisonData())" disabled>
                Average only
              </label>
              <div style="color: var(--text-secondary); font-size: 0.9rem;">Respects cost code filters</div>
            </div>
          </div>
          <div id="costCodeVarianceTable"></div>
        </div>

        <div id="metricsComparison" style="display: none;">
          <div class="card">
            <h3 class="card-title" style="margin-bottom: 1rem;">Comparative Metrics</h3>
            <div id="metricsGrid" class="grid grid-2">
              <!-- Metrics will be populated here -->
            </div>
          </div>
        </div>

        <div id="emptyState" class="empty-state">
          <div class="empty-state-icon">üìä</div>
          <h3>Select Projects to Compare</h3>
          <p>Choose 2 or more projects from the list to see comparative analysis</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Code Mapping Modal -->
  <div id="codeMappingModal" class="modal" style="display: none;">
    <div class="modal-content" style="max-width: 900px; max-height: 80vh; overflow-y: auto;">
      <div class="modal-header">
        <h3>Manage Cost Code Mappings</h3>
        <button class="modal-close" onclick="closeCodeMappingModal()">&times;</button>
      </div>
      <div class="modal-body">
        <p style="color: var(--text-secondary); margin-bottom: 1.5rem;">
          Manually map budget codes to actual payroll codes. These mappings are saved per project and will be used in future comparisons.
        </p>

        <div id="codeMappingProjects"></div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="closeCodeMappingModal()">Close</button>
      </div>
    </div>
  </div>

  <script>
    let allProjects = [];
    let selectedProjects = new Set();
    let comparisonData = [];
    let comparisonCostCodeList = [];
    let selectedComparisonCostCodes = new Set();
    let comparisonCostCodeNames = {};
    let comparisonChart = null;
    let employeeComparisonChart = null;
    let costCodeVarianceChart = null;
    const chartColors = [
      'rgba(37, 99, 235, 1)',
      'rgba(34, 197, 94, 1)',
      'rgba(234, 179, 8, 1)',
      'rgba(239, 68, 68, 1)',
      'rgba(168, 85, 247, 1)',
      'rgba(236, 72, 153, 1)'
    ];
    const packageViewTypes = ['division09', 'package06Combo', 'packageComparison'];

    document.addEventListener('DOMContentLoaded', () => {
      removeDuplicateTimelineControls();
      loadProjects();
    });

    function removeDuplicateTimelineControls() {
      const controlGroups = document.querySelectorAll('.timeline-control-group');
      if (controlGroups.length <= 1) return;

      controlGroups.forEach((group, index) => {
        if (index > 0) {
          group.remove();
        }
      });
    }

    async function loadProjects() {
      try {
        const response = await fetch('/api/projects');
        allProjects = await response.json();
        renderProjectCheckboxes();
      } catch (error) {
        console.error('Error loading projects:', error);
      }
    }

    function renderProjectCheckboxes() {
      const container = document.getElementById('projectCheckboxes');
      
      if (allProjects.length === 0) {
        container.innerHTML = `
          <p style="color: var(--text-secondary); text-align: center; padding: 1rem;">
            No projects available. Create projects first.
          </p>
        `;
        return;
      }

      container.innerHTML = allProjects.map(project => `
        <div class="checkbox-item">
          <input 
            type="checkbox" 
            id="project-${project.id}" 
            value="${project.id}"
            onchange="toggleProject(${project.id})"
          >
          <label for="project-${project.id}">
            ${escapeHtml(project.name)}
            ${project.start_date ? `<br><span style="font-size: 0.75rem; color: var(--text-secondary);">${formatDate(project.start_date)}</span>` : ''}
          </label>
        </div>
      `).join('');
    }

    function toggleProject(projectId) {
      if (selectedProjects.has(projectId)) {
        selectedProjects.delete(projectId);
      } else {
        selectedProjects.add(projectId);
      }
    }

    async function loadComparison() {
      if (selectedProjects.size === 0) {
        alert('Please select at least one project');
        return;
      }

      try {
        const response = await fetch('/api/comparison/timeline', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ projectIds: Array.from(selectedProjects) })
        });

        comparisonData = await response.json();
        comparisonCostCodeNames = buildComparisonCostCodeNames(comparisonData);

        document.getElementById('emptyState').style.display = 'none';
        document.getElementById('metricsComparison').style.display = 'block';

        initializeCostCodeFilters();
        updateCharts();
        renderMetrics();
      } catch (error) {
        console.error('Error loading comparison:', error);
        alert('Error loading comparison data');
      }
    }

    function initializeCostCodeFilters() {
      const uniqueCodes = new Set();

      comparisonData.forEach(project => {
        project.data.forEach(entry => {
          uniqueCodes.add(normalizeCostCodeLabel(entry.cost_code));
        });

        (project.budgetComparison || []).forEach(row => {
          uniqueCodes.add(normalizeCostCodeLabel(row.cost_code));
        });
      });

      comparisonCostCodeList = Array.from(uniqueCodes).sort();
      selectedComparisonCostCodes = new Set(comparisonCostCodeList);

      renderCostCodeList();
      updateCostCodeMasterCheckboxes();
      toggleFilterPanelVisibility(true);
    }

    function renderCostCodeList() {
      const list = document.getElementById('comparisonCostCodeList');
      if (!list) return;

      if (!comparisonCostCodeList.length) {
        list.innerHTML = '<div class="empty-filter">No cost codes available.</div>';
        return;
      }

      list.innerHTML = '';

      comparisonCostCodeList.forEach(code => {
        const label = document.createElement('label');
        label.className = 'checkbox chip';
        label.title = formatComparisonCostCodeLabel(code);

        const input = document.createElement('input');
        input.type = 'checkbox';
        input.value = code;
        input.checked = selectedComparisonCostCodes.has(code);
        input.addEventListener('change', handleCostCodeToggle);

        label.appendChild(input);
        label.appendChild(document.createTextNode(` ${code}`));

        list.appendChild(label);
      });
    }

    function toggleFilterPanelVisibility(show = true) {
      const container = document.getElementById('comparisonFilterPanel');
      if (!container) return;

      const hasFilters = comparisonCostCodeList.length > 0;
      container.style.display = show && hasFilters ? 'flex' : 'none';
    }

    function handleCostCodeToggle(event) {
      const code = event.target.value;
      if (event.target.checked) {
        selectedComparisonCostCodes.add(code);
      } else {
        selectedComparisonCostCodes.delete(code);
      }

      updateCostCodeMasterCheckboxes();
      updateCharts();
    }

    function toggleAllCostCodes(event) {
      const shouldSelectAll = event.target.checked;

      if (shouldSelectAll) {
        selectedComparisonCostCodes = new Set(comparisonCostCodeList);
      } else {
        selectedComparisonCostCodes.clear();
      }

      renderCostCodeList();
      updateCostCodeMasterCheckboxes();
      updateCharts();
    }

    function toggleDivisionCostCodes(event, prefixes) {
      const shouldSelect = event.target.checked;

      comparisonCostCodeList.forEach(code => {
        if (prefixes.some(prefix => code.startsWith(prefix))) {
          if (shouldSelect) {
            selectedComparisonCostCodes.add(code);
          } else {
            selectedComparisonCostCodes.delete(code);
          }
        }
      });

      renderCostCodeList();
      updateCostCodeMasterCheckboxes();
      updateCharts();
    }

    function updateCostCodeMasterCheckboxes() {
      const allToggle = document.getElementById('comparisonCostCodeAllToggle');
      const toggle09 = document.getElementById('comparisonCostCode09Toggle');
      const toggle06Group = document.getElementById('comparisonCostCode06GroupToggle');

      const totalCount = comparisonCostCodeList.length;
      const selectedCount = selectedComparisonCostCodes.size;

      if (allToggle) {
        allToggle.indeterminate = selectedCount > 0 && selectedCount < totalCount;
        allToggle.checked = selectedCount === totalCount && totalCount > 0;
      }

      if (toggle09) {
        const codes09 = comparisonCostCodeList.filter(code => code.startsWith('09'));
        const selected09 = codes09.filter(code => selectedComparisonCostCodes.has(code)).length;
        toggle09.indeterminate = selected09 > 0 && selected09 < codes09.length;
        toggle09.checked = codes09.length > 0 && selected09 === codes09.length;
      }

      if (toggle06Group) {
        const prefixes = ['06', '08', '10', '11', '12'];
        const codes06Group = comparisonCostCodeList.filter(code => prefixes.some(prefix => code.startsWith(prefix)));
        const selected06Group = codes06Group.filter(code => selectedComparisonCostCodes.has(code)).length;
        toggle06Group.indeterminate = selected06Group > 0 && selected06Group < codes06Group.length;
        toggle06Group.checked = codes06Group.length > 0 && selected06Group === codes06Group.length;
      }
    }

    function toggleFilterSection(sectionId, trigger) {
      const section = document.getElementById(sectionId);
      if (!section) return;

      const isHidden = section.classList.toggle('collapsed');
      section.style.display = isHidden ? 'none' : 'grid';
      if (trigger) {
        trigger.textContent = isHidden ? 'Show' : 'Hide';
        trigger.setAttribute('aria-expanded', (!isHidden).toString());
      }
    }

    function updateCharts() {
      const filteredData = getFilteredComparisonData();
      updateComparisonChart(filteredData);
      updateEmployeeChart(filteredData);
      renderCostCodeVarianceChart(filteredData);
    }

    function updateComparisonChart(data = comparisonData) {
      const timelineType = document.getElementById('timelineType').value;
      const viewType = document.getElementById('comparisonView').value;

      if (data.length === 0) return;

      const ctx = document.getElementById('comparisonChart');

      if (comparisonChart) {
        comparisonChart.destroy();
      }

      let chartData = timelineType === 'project'
        ? buildProjectTimelineChart(data, viewType)
        : buildCalendarTimelineChart(data, viewType);

      chartData = applyAverageCurve(chartData);

      const tooltipCallbacks = {};

      if (viewType === 'costCode') {
        tooltipCallbacks.label = (context) => {
          const value = context.parsed.y;
          const rawLabel = context.dataset.label || '';
          const labelParts = rawLabel.split(' - ');
          const code = labelParts.pop();
          const projectLabel = labelParts.join(' - ');
          const costCodeLabel = formatComparisonCostCodeLabel(code);
          const displayLabel = projectLabel ? `${projectLabel} - ${costCodeLabel}` : costCodeLabel;
          const formattedHours = Number.isFinite(value) ? formatHours(value) : '0.00';
          return `${displayLabel}: ${formattedHours} hrs`;
        };
      }

      comparisonChart = new Chart(ctx, {
        type: 'line',
        data: chartData,
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: true,
              position: 'top'
            },
            tooltip: {
              mode: 'index',
              intersect: false,
              callbacks: tooltipCallbacks
            }
          },
          scales: {
            x: {
              grid: {
                display: true
              },
              title: {
                display: true,
                text: timelineType === 'project' ? 'Project Month' : 'Calendar Month'
              }
            },
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Hours'
              }
            }
          },
          interaction: {
            mode: 'nearest',
            axis: 'x',
            intersect: false
          }
        }
      });
    }

    function updateEmployeeChart(data = comparisonData) {
      const timelineType = document.getElementById('timelineType').value;
      const metric = document.getElementById('employeeComparisonMetric')?.value || 'unique';
      const subtitle = document.getElementById('employeeComparisonSubtitle');

      if (data.length === 0) return;

      const ctx = document.getElementById('employeeComparisonChart');

      if (employeeComparisonChart) {
        employeeComparisonChart.destroy();
      }

      const chartData = buildEmployeeChartData(data, timelineType, metric);

      if (subtitle) {
        subtitle.textContent = metric === 'average'
          ? 'Average daily crew size per month'
          : 'Unique employees working each month';
      }

      employeeComparisonChart = new Chart(ctx, {
        type: 'line',
        data: chartData,
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: true,
              position: 'top'
            },
            tooltip: {
              mode: 'index',
              intersect: false
            }
          },
          scales: {
            x: {
              grid: { display: true },
              title: {
                display: true,
                text: timelineType === 'project' ? 'Project Month' : 'Calendar Month'
              }
            },
            y: {
              beginAtZero: true,
              title: { display: true, text: 'Employees' },
              ticks: { stepSize: 1 }
            }
          },
          interaction: {
            mode: 'nearest',
            axis: 'x',
            intersect: false
          }
        }
      });
    }

    function getFilteredComparisonData() {
      if (!selectedComparisonCostCodes.size) {
        return comparisonData.map(project => ({
          ...project,
          data: [],
          rawEntries: project.rawEntries || [],
          budgetComparison: [],
          employeeStats: buildEmployeeStatsFromEntries([], project.projectStartDate)
        }));
      }

      return comparisonData.map(project => {
        const filteredEntries = filterBySelectedCostCodes(project.data);
        const filteredRawEntries = filterRawEntriesByCostCode(project.rawEntries || []);
        const filteredBudget = filterBudgetRows(project.budgetComparison || []);

        return {
          ...project,
          data: filteredEntries,
          rawEntries: filteredRawEntries,
          budgetComparison: filteredBudget,
          employeeStats: buildEmployeeStatsFromEntries(filteredRawEntries, project.projectStartDate)
        };
      });
    }

    function filterBySelectedCostCodes(entries) {
      if (!selectedComparisonCostCodes.size) return [];
      return entries.filter(entry => selectedComparisonCostCodes.has(normalizeCostCodeLabel(entry.cost_code)));
    }

    function filterRawEntriesByCostCode(entries) {
      if (!selectedComparisonCostCodes.size) return [];
      return entries.filter(entry => selectedComparisonCostCodes.has(normalizeCostCodeLabel(entry.cost_code)));
    }

    function filterBudgetRows(rows) {
      if (!selectedComparisonCostCodes.size) return [];
      return rows.filter(row => selectedComparisonCostCodes.has(normalizeCostCodeLabel(row.cost_code)));
    }

    function buildEmployeeStatsFromEntries(entries, projectStartDate) {
      if (!entries || !entries.length) {
        return { projectTimeline: {}, calendarTimeline: {} };
      }

      const firstDate = projectStartDate ? new Date(projectStartDate + 'T00:00:00') : new Date(Math.min(...entries.map(e => new Date(e.date))));
      const projectMonthStats = {};
      const calendarMonthStats = {};

      entries.forEach(entry => {
        if (!entry.date) return;

        const entryDate = new Date(entry.date);
        const monthsDiff = Math.floor((entryDate - firstDate) / (30.44 * 24 * 60 * 60 * 1000)) + 1;
        const calendarMonth = entry.date.substring(0, 7);

        if (!projectMonthStats[monthsDiff]) {
          projectMonthStats[monthsDiff] = { unique: new Set(), days: {} };
        }
        if (!projectMonthStats[monthsDiff].days[entry.date]) {
          projectMonthStats[monthsDiff].days[entry.date] = new Set();
        }
        projectMonthStats[monthsDiff].unique.add(entry.employee_name);
        projectMonthStats[monthsDiff].days[entry.date].add(entry.employee_name);

        if (!calendarMonthStats[calendarMonth]) {
          calendarMonthStats[calendarMonth] = { unique: new Set(), days: {} };
        }
        if (!calendarMonthStats[calendarMonth].days[entry.date]) {
          calendarMonthStats[calendarMonth].days[entry.date] = new Set();
        }
        calendarMonthStats[calendarMonth].unique.add(entry.employee_name);
        calendarMonthStats[calendarMonth].days[entry.date].add(entry.employee_name);
      });

      const buildStats = (statMap) => Object.entries(statMap).reduce((acc, [key, value]) => {
        const dayCounts = Object.values(value.days).map(set => set.size);
        const averageDailyEmployeesRaw = dayCounts.length
          ? dayCounts.reduce((sum, count) => sum + count, 0) / dayCounts.length
          : 0;

        acc[key] = {
          uniqueEmployees: value.unique.size,
          averageDailyEmployees: Number(averageDailyEmployeesRaw.toFixed(2))
        };
        return acc;
      }, {});

      return {
        projectTimeline: buildStats(projectMonthStats),
        calendarTimeline: buildStats(calendarMonthStats)
      };
    }

    function buildProjectTimelineChart(data, viewType) {
      // Find max project month across all projects
      let maxMonth = 0;
      data.forEach(project => {
        project.data.forEach(entry => {
          if (entry.project_month > maxMonth) {
            maxMonth = entry.project_month;
          }
        });
      });

      const months = Array.from({ length: maxMonth }, (_, i) => i + 1);

      if (viewType === 'total') {
        const datasets = data.map((project, index) => buildTotalDataset(project, months, 'project_month', index));

        return {
          labels: months.map(m => `Month ${m}`),
          datasets
        };
      }

      if (packageViewTypes.includes(viewType)) {
        const packageDatasets = buildPackageDatasets(data, months, 'project_month', viewType);
        return {
          labels: months.map(m => `Month ${m}`),
          datasets: packageDatasets
        };
      }

      const categoryDatasets = buildCategoryDatasets(data, months, 'project_month', viewType);
      return {
        labels: months.map(m => `Month ${m}`),
        datasets: categoryDatasets
      };
    }

    function buildCalendarTimelineChart(data, viewType) {
      // Get all unique calendar months
      const allMonths = new Set();
      data.forEach(project => {
        project.data.forEach(entry => {
          allMonths.add(entry.calendar_month);
        });
      });

      const months = Array.from(allMonths).sort();

      if (viewType === 'total') {
        const datasets = data.map((project, index) => buildTotalDataset(project, months, 'calendar_month', index));

        return {
          labels: months.map(formatMonth),
          datasets
        };
      }

      if (packageViewTypes.includes(viewType)) {
        const packageDatasets = buildPackageDatasets(data, months, 'calendar_month', viewType);
        return {
          labels: months.map(formatMonth),
          datasets: packageDatasets
        };
      }

      const categoryDatasets = buildCategoryDatasets(data, months, 'calendar_month', viewType);
      return {
        labels: months.map(formatMonth),
        datasets: categoryDatasets
      };
    }

    function buildEmployeeChartData(data, timelineType, metric = 'unique') {
      if (timelineType === 'project') {
        let maxMonth = 0;
        data.forEach(project => {
          project.data.forEach(entry => {
            if (entry.project_month > maxMonth) {
              maxMonth = entry.project_month;
            }
          });
        });

        const months = Array.from({ length: maxMonth }, (_, i) => i + 1);

        const datasets = data.map((project, index) => {
          const monthlyEmployees = project.employeeStats?.projectTimeline || {};

          return {
            label: project.data[0]?.project_name || `Project ${project.projectId}`,
            data: months.map(m => {
              const stats = monthlyEmployees[m] || {};
              const value = metric === 'average' ? stats.averageDailyEmployees : stats.uniqueEmployees;
              return typeof value === 'number' ? value : Number(value) || 0;
            }),
            borderColor: chartColors[index % chartColors.length],
            backgroundColor: chartColors[index % chartColors.length].replace('1)', '0.15)'),
            borderWidth: 2,
            tension: 0.1,
            fill: false,
            pointRadius: 3,
            pointHoverRadius: 5
          };
        });

        return {
          labels: months.map(m => `Month ${m}`),
          datasets
        };
      }

      const allMonths = new Set();
      data.forEach(project => {
        project.data.forEach(entry => {
          allMonths.add(entry.calendar_month);
        });
      });

      const months = Array.from(allMonths).sort();

      const datasets = data.map((project, index) => {
        const monthlyEmployees = project.employeeStats?.calendarTimeline || {};

        return {
          label: project.data[0]?.project_name || `Project ${project.projectId}`,
          data: months.map(m => {
            const stats = monthlyEmployees[m] || {};
            const value = metric === 'average' ? stats.averageDailyEmployees : stats.uniqueEmployees;
            return typeof value === 'number' ? value : Number(value) || 0;
          }),
          borderColor: chartColors[index % chartColors.length],
          backgroundColor: chartColors[index % chartColors.length].replace('1)', '0.15)'),
          borderWidth: 2,
          tension: 0.1,
          fill: false,
          pointRadius: 3,
          pointHoverRadius: 5
        };
      });

      return {
        labels: months.map(formatMonth),
        datasets
      };
    }

    function applyAverageCurve(chartData) {
      const mode = document.getElementById('averageCurveMode')?.value || 'actual';
      const showAverages = document.getElementById('showAverageCurvesToggle')?.checked;
      const includeCombined = document.getElementById('combinedAverageToggle')?.checked;

      if (!showAverages || mode === 'actual' || !chartData?.datasets?.length) {
        return chartData;
      }

      const baseDatasets = chartData.datasets.map(dataset => ({
        ...dataset,
        data: (dataset.data || []).map(value => Number(value) || 0)
      }));

      const projectAverageDatasets = baseDatasets.map(dataset => {
        const baseBackground = typeof dataset.backgroundColor === 'string'
          ? dataset.backgroundColor
          : 'rgba(16, 24, 40, 0.2)';

        return {
          ...dataset,
          label: `${dataset.label} Average`,
          data: buildRollingAverage(dataset.data),
          backgroundColor: baseBackground.replace('1)', '0.08)'),
          borderDash: [6, 4],
          tension: 0.35,
          pointRadius: 0,
          pointHoverRadius: 0,
          fill: false
        };
      });

      const combinedAverageDataset = includeCombined
        ? buildCombinedAverageDataset(baseDatasets, chartData.labels?.length || 0)
        : null;

      if (mode === 'average') {
        const datasets = [...projectAverageDatasets];
        if (combinedAverageDataset) datasets.push(combinedAverageDataset);
        return { ...chartData, datasets };
      }

      const overlayDatasets = [...baseDatasets, ...projectAverageDatasets];
      if (combinedAverageDataset) overlayDatasets.push(combinedAverageDataset);

      return { ...chartData, datasets: overlayDatasets };
    }

    function buildRollingAverage(values) {
      if (!Array.isArray(values) || !values.length) return [];

      return values.map((_, index) => {
        const start = Math.max(0, index - 1);
        const end = Math.min(values.length, index + 2);
        const slice = values.slice(start, end).filter(Number.isFinite);
        if (!slice.length) return 0;
        const avg = slice.reduce((sum, value) => sum + value, 0) / slice.length;
        return Number(avg.toFixed(2));
      });
    }

    function buildCombinedAverageDataset(baseDatasets, labelCount) {
      const totals = Array(labelCount).fill(0);
      const counts = Array(labelCount).fill(0);

      baseDatasets.forEach(dataset => {
        dataset.data.forEach((value, index) => {
          if (Number.isFinite(value)) {
            totals[index] += value;
            counts[index] += 1;
          }
        });
      });

      const averages = totals.map((sum, index) => counts[index]
        ? Number((sum / counts[index]).toFixed(2))
        : 0
      );

      return {
        label: 'Combined Average',
        data: averages,
        borderColor: 'rgba(16, 24, 40, 0.9)',
        backgroundColor: 'rgba(16, 24, 40, 0.12)',
        borderWidth: 3,
        tension: 0.35,
        pointRadius: 0,
        pointHoverRadius: 0,
        borderDash: [8, 6],
        fill: false
      };
    }

    function buildVarianceAverageDataset(datasets = [], labels = []) {
      const totals = labels.map(() => 0);
      const counts = labels.map(() => 0);

      datasets.forEach(dataset => {
        (dataset.data || []).forEach((value, index) => {
          if (Number.isFinite(value)) {
            totals[index] += value;
            counts[index] += 1;
          }
        });
      });

      const averages = totals.map((sum, index) => counts[index]
        ? Number((sum / counts[index]).toFixed(2))
        : 0
      );

      return {
        label: 'All Projects Average',
        data: averages,
        backgroundColor: 'rgba(16, 24, 40, 0.78)',
        borderColor: 'rgba(16, 24, 40, 0.95)',
        borderWidth: 2,
        costCodeRows: null,
        isAverageBar: true
      };
    }

    function renderCostCodeVarianceChart(data = comparisonData) {
      const container = document.getElementById('costCodeVarianceTable');
      const card = document.getElementById('costCodeVarianceCard');
      const showAverageBar = document.getElementById('showVarianceAverageBar')?.checked;
      const averageOnlyToggle = document.getElementById('varianceAverageOnlyToggle');
      const averageOnly = !!showAverageBar && !!averageOnlyToggle?.checked;

      if (averageOnlyToggle) {
        averageOnlyToggle.disabled = !showAverageBar;
        if (!showAverageBar) averageOnlyToggle.checked = false;
      }

      if (!container || !card) return;

      if (costCodeVarianceChart) {
        costCodeVarianceChart.destroy();
        costCodeVarianceChart = null;
      }

      if (!data.length) {
        card.style.display = 'none';
        return;
      }

      const costCodes = new Set();
      data.forEach(project => {
        (project.budgetComparison || []).forEach(row => {
          costCodes.add(normalizeCostCodeLabel(row.cost_code));
        });
      });

      card.style.display = 'block';

      if (!selectedComparisonCostCodes.size) {
        container.innerHTML = '<p style="color: var(--text-secondary);">Select cost codes to see variance.</p>';
        return;
      }

      if (!costCodes.size) {
        container.innerHTML = '<p style="color: var(--text-secondary);">No variance data for the selected cost codes yet.</p>';
        return;
      }

      const sortedCodes = Array.from(costCodes).sort();
      const projectDatasets = data.map((project, index) => {
        const color = getColor(index);
        const rowsByCode = {};

        const values = sortedCodes.map(code => {
          const match = (project.budgetComparison || []).find(row => normalizeCostCodeLabel(row.cost_code) === code);
          if (match) {
            rowsByCode[code] = match;
          }
          return match ? Number(match.variance_hours) || 0 : null;
        });

        return {
          label: project.data[0]?.project_name || getProjectName(project.projectId),
          data: values,
          backgroundColor: color.replace('1)', '0.72)'),
          borderColor: color,
          borderWidth: 1,
          costCodeRows: rowsByCode
        };
      });

      const averageDataset = showAverageBar
        ? buildVarianceAverageDataset(projectDatasets, sortedCodes)
        : null;

      const datasets = averageOnly && averageDataset
        ? [averageDataset]
        : averageDataset
          ? [...projectDatasets, averageDataset]
          : projectDatasets;

      const allValues = datasets.flatMap(ds => ds.data.filter(v => Number.isFinite(v)));
      const suggestedMin = allValues.length ? Math.min(0, Math.min(...allValues) * 1.1) : 0;
      const suggestedMax = allValues.length ? Math.max(0, Math.max(...allValues) * 1.1) : 0;

      container.innerHTML = `
        <div class="chart-container" style="min-height: 380px;">
          <canvas id="costCodeVarianceChart"></canvas>
        </div>
      `;

      const ctx = document.getElementById('costCodeVarianceChart');
      costCodeVarianceChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: sortedCodes,
          datasets
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { position: 'top' },
            tooltip: {
              callbacks: {
                label: (context) => {
                  const code = context.label;
                  const row = context.dataset.costCodeRows?.[code];
                  const varianceHours = context.parsed.y;
                  const costCodeLabel = formatComparisonCostCodeLabel(code);
                  const varianceLabel = Number.isFinite(varianceHours)
                    ? varianceHours.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })
                    : '‚Äî';

                  if (context.dataset.isAverageBar) {
                    return `${context.dataset.label} ‚Äì ${costCodeLabel}: ${varianceLabel} hrs`;
                  }

                  if (!row) return `${context.dataset.label}: ${varianceLabel} hrs`;

                  const budget = formatHours(row.budget_hours);
                  const actual = formatHours(row.actual_hours);
                  const percent = formatPercentVariance(row.variance_percent);
                  return `${context.dataset.label} ‚Äì ${costCodeLabel}: ${varianceLabel} hrs (Budget: ${budget}, Spent: ${actual}, %: ${percent})`;
                }
              }
            }
          },
          scales: {
            x: {
              stacked: false,
              ticks: {
                autoSkip: false,
                maxRotation: 60,
                minRotation: 30
              }
            },
            y: {
              title: { display: true, text: 'Variance (hrs)' },
              suggestedMin,
              suggestedMax
            }
          }
        }
      });
    }

    function renderMetrics() {
      const metricsGrid = document.getElementById('metricsGrid');
      
      const metrics = comparisonData.map(project => {
        const totalHours = project.data.reduce((sum, entry) => sum + (Number(entry.total_hours) || 0), 0);
        const uniqueEmployees = new Set(project.data.map(e => e.employee_name)).size;
        const costCodes = new Set(project.data.map(e => e.cost_code).filter(Boolean)).size;
        const projectMonths = Math.max(...project.data.map(e => e.project_month));
        const avgHoursPerMonth = projectMonths ? totalHours / projectMonths : 0;
        const budgetedHours = Number(project.budgetSummary?.budgetedHours) || null;
        const spentHours = Number(project.budgetSummary?.actualHours);
        const varianceHours = Number(project.budgetSummary?.varianceHours);

        return {
          name: project.data[0]?.project_name || `Project ${project.projectId}`,
          totalHours,
          uniqueEmployees,
          costCodes,
          projectMonths,
          avgHoursPerMonth,
          budgetedHours,
          spentHours,
          varianceHours
        };
      });

      metricsGrid.innerHTML = metrics.map(m => `
        <div class="card" style="background-color: var(--background);">
          <h4 style="margin-bottom: 1rem; font-size: 1rem;">${escapeHtml(m.name)}</h4>
          <div style="display: grid; gap: 0.75rem;">
            <div>
              <div style="font-size: 1.5rem; font-weight: 700; color: var(--primary-color);">
                ${m.totalHours.toLocaleString()}
              </div>
              <div style="color: var(--text-secondary); font-size: 0.813rem;">Total Hours</div>
            </div>
            <div>
              <div style="font-size: 1.25rem; font-weight: 600;">
                ${m.avgHoursPerMonth.toLocaleString(undefined, { maximumFractionDigits: 0 })}
              </div>
              <div style="color: var(--text-secondary); font-size: 0.813rem;">Avg Hours/Month</div>
            </div>
            <div style="display: flex; justify-content: space-between; padding-top: 0.75rem; border-top: 1px solid var(--border-color);">
              <div>
                <div style="font-weight: 600;">${m.uniqueEmployees}</div>
                <div style="color: var(--text-secondary); font-size: 0.75rem;">Employees</div>
              </div>
              <div>
                <div style="font-weight: 600;">${m.projectMonths}</div>
                <div style="color: var(--text-secondary); font-size: 0.75rem;">Months</div>
              </div>
              <div>
                <div style="font-weight: 600;">${m.costCodes}</div>
                <div style="color: var(--text-secondary); font-size: 0.75rem;">Cost Codes</div>
              </div>
            </div>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 0.75rem; padding-top: 0.75rem; border-top: 1px solid var(--border-color);">
              <div>
                <div style="font-weight: 600;">${m.budgetedHours !== null ? m.budgetedHours.toLocaleString() : '‚Äî'}</div>
                <div style="color: var(--text-secondary); font-size: 0.75rem;">Budgeted Hours</div>
              </div>
              <div>
                <div style="font-weight: 600;">${m.spentHours !== undefined && m.spentHours !== null ? m.spentHours.toLocaleString() : '‚Äî'}</div>
                <div style="color: var(--text-secondary); font-size: 0.75rem;">Spent Hours</div>
              </div>
              <div>
                <div style="font-weight: 600; color: ${m.varianceHours >= 0 ? 'var(--danger-color, #ef4444)' : 'var(--success-color, #22c55e)'};">${m.varianceHours !== undefined && m.varianceHours !== null ? m.varianceHours.toLocaleString() : '‚Äî'}</div>
                <div style="color: var(--text-secondary); font-size: 0.75rem;">Delta (Spent - Budget)</div>
              </div>
            </div>
          </div>
        </div>
      `).join('');
    }

    function getProjectName(projectId) {
      const match = allProjects.find(p => Number(p.id) === Number(projectId));
      return match ? match.name : `Project ${projectId}`;
    }

    function formatDate(dateStr) {
      if (!dateStr) return '';
      const date = new Date(dateStr + 'T00:00:00');
      return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
    }

    function formatMonth(monthStr) {
      const [year, month] = monthStr.split('-');
      const date = new Date(year, month - 1);
      return date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
    }

    function formatHours(value) {
      if (value === null || value === undefined || Number.isNaN(value)) return '‚Äî';
      return Number(value || 0).toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    }

    function formatVarianceBadge(value) {
      const numeric = Number(value || 0);
      const sign = numeric > 0 ? '+' : '';
      const color = numeric > 0 ? '#ef4444' : numeric < 0 ? '#22c55e' : '#0f172a';
      return `<span style="font-weight: 700; color: ${color};">${sign}${numeric.toFixed(2)}</span>`;
    }

    function formatPercentVariance(value) {
      if (value === null || value === undefined || Number.isNaN(value)) return '‚Äî';
      const sign = value > 0 ? '+' : '';
      return `${sign}${Number(value).toFixed(1)}%`;
    }

    function normalizeCostCodeValue(code) {
      if (code === undefined || code === null) return null;
      const [mainPart] = code.toString().split('.');
      const numeric = mainPart.replace(/\D/g, '').trim();
      return numeric || null;
    }

    function buildComparisonCostCodeNames(data = []) {
      const map = {};

      data.forEach(project => {
        Object.entries(project.costCodeNames || {}).forEach(([code, name]) => {
          const normalized = normalizeCostCodeValue(code);
          const cleanName = name?.toString().trim();
          if (!normalized || !cleanName) return;
          if (!map[normalized]) {
            map[normalized] = cleanName;
          }
        });

        (project.budgetComparison || []).forEach(row => {
          if (!row.cost_code || !row.cost_code_name) return;
          const normalized = normalizeCostCodeValue(row.cost_code);
          const cleanName = row.cost_code_name?.toString().trim();
          if (!normalized || !cleanName) return;
          if (!map[normalized]) {
            map[normalized] = cleanName;
          }
        });
      });

      return map;
    }

    function getComparisonCostCodeName(code) {
      const normalized = normalizeCostCodeValue(code);
      if (!normalized) return null;
      return comparisonCostCodeNames?.[normalized] || null;
    }

    function formatComparisonCostCodeLabel(code) {
      if (!code && code !== 0) return 'Unknown';
      const name = getComparisonCostCodeName(code);
      return name ? `${code} ‚Äî ${name}` : code.toString();
    }

    function normalizeCostCodeLabel(code) {
      if (code === null || code === undefined) return 'Unknown';
      const normalized = code.toString().trim();
      return normalized || 'Unknown';
    }

    function buildTotalDataset(project, months, monthKey, colorIndex) {
      const monthlyTotals = {};

      project.data.forEach(entry => {
        const month = entry[monthKey];
        if (!monthlyTotals[month]) {
          monthlyTotals[month] = 0;
        }
        monthlyTotals[month] += Number(entry.total_hours) || 0;
      });

      const color = getColor(colorIndex);

      return {
        label: project.data[0]?.project_name || `Project ${project.projectId}`,
        data: months.map(m => monthlyTotals[m] || 0),
        borderColor: color,
        backgroundColor: color.replace('1)', '0.1)'),
        borderWidth: 2,
        tension: 0.1,
        fill: false
      };
    }

    function buildCategoryDatasets(data, months, monthKey, viewType) {
      const datasets = [];

      data.forEach((project, projectIndex) => {
        const categoryTotals = {};
        project.data.forEach(entry => {
          const category = getCategoryLabel(viewType, entry);
          if (!category) return;

          const key = `${project.projectId}|${category}`;
          if (!categoryTotals[key]) {
            categoryTotals[key] = {
              projectName: project.data[0]?.project_name || `Project ${project.projectId}`,
              category,
              totals: {}
            };
          }

          const month = entry[monthKey];
          const hours = Number(entry.total_hours) || 0;
          categoryTotals[key].totals[month] = (categoryTotals[key].totals[month] || 0) + hours;
        });

        Object.values(categoryTotals).forEach((catData, catIndex) => {
          const color = getColor(projectIndex + catIndex);
          datasets.push({
            label: `${catData.projectName} - ${catData.category}`,
            data: months.map(m => catData.totals[m] || 0),
            borderColor: color,
            backgroundColor: color.replace('1)', '0.25)'),
            borderWidth: 2,
            tension: 0.1,
            fill: true
          });
        });
      });

      return datasets;
    }

    function buildPackageDatasets(data, months, monthKey, viewType) {
      const packageMap = {
        division09: { '09 Package': ['09'] },
        package06Combo: { '06 Package': ['06', '08', '10', '11', '12'] },
        packageComparison: {
          '09 Package': ['09'],
          '06 Package': ['06', '08', '10', '11', '12']
        }
      };

      const targetPackages = packageMap[viewType] || {};
      const packageKeys = Object.keys(targetPackages);
      const datasets = [];

      data.forEach((project, projectIndex) => {
        const projectName = project.data[0]?.project_name || `Project ${project.projectId}`;

        packageKeys.forEach((pkgName, pkgIndex) => {
          const divisions = targetPackages[pkgName];
          const monthlyTotals = {};

          project.data.forEach(entry => {
            const division = getCostCodeDivision(entry.cost_code);
            if (!divisions.includes(division)) return;

            const month = entry[monthKey];
            const hours = Number(entry.total_hours) || 0;
            monthlyTotals[month] = (monthlyTotals[month] || 0) + hours;
          });

          const color = getColor((projectIndex * packageKeys.length) + pkgIndex);

          datasets.push({
            label: `${projectName} - ${pkgName}`,
            data: months.map(m => monthlyTotals[m] || 0),
            borderColor: color,
            backgroundColor: color.replace('1)', '0.2)'),
            borderWidth: 2,
            tension: 0.1,
            fill: true
          });
        });
      });

      return datasets;
    }

    function getCategoryLabel(viewType, entry) {
      if (viewType === 'costCode') return entry.cost_code;
      if (viewType === 'costCodeDivision') return formatCostCodeDivision(entry.cost_code);
      if (viewType === 'payClass') return entry.pay_class;
      if (viewType === 'job') return entry.job_description;
      return null;
    }

    function formatCostCodeDivision(costCode) {
      if (!costCode) return 'Unknown';
      const trimmed = costCode.toString().trim();
      if (trimmed.length < 2) return trimmed || 'Unknown';
      return `${trimmed.slice(0, 2)} Division`;
    }

    function getCostCodeDivision(costCode) {
      if (!costCode) return '';
      const trimmed = costCode.toString().trim();
      if (trimmed.length < 2) return '';
      return trimmed.slice(0, 2);
    }

    function getColor(index) {
      if (index < chartColors.length) return chartColors[index];
      const hue = (index * 47) % 360;
      return `hsla(${hue}, 65%, 50%, 1)`;
    }

    function escapeHtml(text) {
      if (!text) return '';
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Code Mapping Modal Functions
    async function openCodeMappingModal() {
      if (!comparisonData || !comparisonData.length) {
        alert('Please load comparison data first');
        return;
      }

      const modal = document.getElementById('codeMappingModal');
      modal.style.display = 'flex';

      await loadCodeMappings();
    }

    function closeCodeMappingModal() {
      const modal = document.getElementById('codeMappingModal');
      modal.style.display = 'none';
    }

    async function loadCodeMappings() {
      const container = document.getElementById('codeMappingProjects');
      container.innerHTML = '<p style="text-align: center; padding: 2rem;">Loading mappings...</p>';

      try {
        // Load mappings for each project
        const projectMappings = await Promise.all(
          comparisonData.map(async project => {
            const response = await fetch(`/api/projects/${project.projectId}/code-mappings`);
            const data = response.ok ? await response.json() : { mappings: {} };
            return { project, mappings: data.mappings || {} };
          })
        );

        mergeMappedCostCodeNames(projectMappings);
        renderCodeMappings(projectMappings);
      } catch (error) {
        console.error('Error loading code mappings:', error);
        container.innerHTML = '<p style="color: var(--danger-color); text-align: center;">Error loading mappings</p>';
      }
    }


    function mergeMappedCostCodeNames(projectMappings) {
      const updatedNames = { ...(comparisonCostCodeNames || {}) };

      projectMappings.forEach(({ project, mappings }) => {
        const budgetNameMap = {};

        (project.budgetComparison || []).forEach(row => {
          if (!row.cost_code || !row.cost_code_name) return;
          const normalized = normalizeCostCodeValue(row.cost_code);
          const cleanName = row.cost_code_name?.toString().trim();
          if (!normalized || !cleanName) return;
          budgetNameMap[normalized] = cleanName;
        });

        Object.entries(mappings || {}).forEach(([budget, actual]) => {
          const normalizedActual = normalizeCostCodeValue(actual);
          const normalizedBudget = normalizeCostCodeValue(budget);
          if (!normalizedActual || !normalizedBudget) return;

          if (!updatedNames[normalizedActual] && budgetNameMap[normalizedBudget]) {
            updatedNames[normalizedActual] = budgetNameMap[normalizedBudget];
          }
        });
      });

      comparisonCostCodeNames = updatedNames;
    }


    function renderCodeMappings(projectMappings) {
      const container = document.getElementById('codeMappingProjects');

      container.innerHTML = projectMappings.map(({ project, mappings }) => {
        const projectName = project.data[0]?.project_name || `Project ${project.projectId}`;

        const budgetCodes = new Set();
        const actualCodes = new Set();
        const budgetStats = {};
        const actualTotals = {};

        (project.budgetComparison || []).forEach(row => {
          if (row.cost_code) {
            budgetCodes.add(row.cost_code);
            budgetStats[row.cost_code] = {
              budget: Number(row.budget_hours) || 0,
              actual: Number(row.actual_hours) || 0
            };
            if (row.actual_hours > 0) {
              actualCodes.add(row.cost_code);
            }
          }
        });

        (project.data || []).forEach(entry => {
          if (entry.cost_code) {
            actualCodes.add(entry.cost_code);
            const hours = Number(entry.total_hours) || 0;
            actualTotals[entry.cost_code] = (actualTotals[entry.cost_code] || 0) + hours;
          }
        });

        const sortedBudgetCodes = Array.from(budgetCodes).sort();
        const sortedActualCodes = Array.from(actualCodes).sort();
        const mappedActualToBudget = Object.entries(mappings || {}).reduce((acc, [budget, actual]) => {
          acc[actual] = budget;
          return acc;
        }, {});

        const matchedAutomatically = sortedBudgetCodes.filter(code => {
          const stats = budgetStats[code] || {};
          const budgetHours = Number(stats.budget) || 0;
          const spentHours = (Number(stats.actual) || 0) + (Number(actualTotals[code]) || 0);
          return budgetHours > 0 && spentHours > 0;
        });

        const matchedCount = new Set([
          ...matchedAutomatically,
          ...Object.keys(mappings || {})
        ]).size;

        const unmatchedBudgetCodes = sortedBudgetCodes.filter(code => {
          const stats = budgetStats[code] || {};
          const budgetHours = Number(stats.budget) || 0;
          const spentHours = (Number(stats.actual) || 0) + (Number(actualTotals[code]) || 0);
          return budgetHours > 0 && spentHours === 0;
        });

        const unmatchedActualCodes = sortedActualCodes.filter(code => {
          const stats = budgetStats[code] || {};
          const budgetHours = Number(stats.budget) || 0;
          if (budgetHours > 0) return false;
          const mappedBudget = mappedActualToBudget[code];
          return !mappedBudget;
        });

        const budgetRows = sortedBudgetCodes.map(code => {
          const mappedTarget = mappings[code] || '';
          const availableActualCodes = unmatchedActualCodes.filter(actualCode => {
            const mappedBudget = mappedActualToBudget[actualCode];
            return !mappedBudget || mappedBudget === code;
          });

          if (mappedTarget && !availableActualCodes.includes(mappedTarget)) {
            availableActualCodes.unshift(mappedTarget);
          }

          const budgetInfo = budgetStats[code] || { budget: 0, actual: 0 };
          const hasSpentHours = (Number(budgetInfo.actual) || 0) + (Number(actualTotals[code]) || 0) > 0;
          const mappedLabel = mappedTarget
            ? `<span style="display: inline-flex; align-items: center; gap: 0.35rem; padding: 0.35rem 0.5rem; background: var(--success-surface); border-radius: 999px; color: var(--success-color); font-size: 0.8rem;">Matched to ${escapeHtml(mappedTarget)}</span>`
            : hasSpentHours
              ? `<span style="display: inline-flex; align-items: center; gap: 0.35rem; padding: 0.35rem 0.5rem; background: rgba(34,197,94,0.12); border-radius: 999px; color: var(--success-color); font-size: 0.8rem;">Auto-matched by code</span>`
              : `<span style="display: inline-flex; align-items: center; gap: 0.35rem; padding: 0.35rem 0.5rem; background: var(--card-background); border-radius: 999px; color: var(--text-secondary); font-size: 0.8rem;">Unmatched</span>`;

          return `
            <div style="display: grid; grid-template-columns: 1.2fr 1fr 0.9fr; gap: 0.75rem; align-items: center; padding: 0.65rem 0.75rem; border: 1px solid var(--border-color); border-radius: 6px; background: var(--card-background);">
              <div style="display: grid; gap: 0.25rem;">
                <div style="font-family: monospace; font-weight: 600;">${escapeHtml(code)}</div>
                <div style="color: var(--text-secondary); font-size: 0.85rem;">Budgeted ${formatHours(budgetInfo.budget)} hrs ¬∑ Spent ${formatHours(budgetInfo.actual)} hrs</div>
              </div>
              <div style="display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap;">
                ${mappedLabel}
              </div>
              <div style="display: flex; align-items: center; gap: 0.5rem; justify-content: flex-end;">
                <select
                  class="form-control"
                  style="min-width: 180px; font-family: monospace;"
                  onchange="handleMappingSelect(${project.projectId}, '${encodeURIComponent(code)}', this.value)"
                  value="${escapeHtml(mappedTarget)}"
                >
                  <option value="">Select actual code...</option>
                  ${availableActualCodes.map(actualCode => `
                    <option value="${escapeHtml(actualCode)}" ${mappedTarget === actualCode ? 'selected' : ''}>${escapeHtml(actualCode)}</option>
                  `).join('')}
                </select>
              </div>
            </div>
          `;
        }).join('') || '<div class="empty-filter">No budget codes found.</div>';

        const actualRows = sortedActualCodes.map(code => {
          const mappedBudget = mappedActualToBudget[code];
          const stats = budgetStats[code] || {};
          const budgetHours = Number(stats.budget) || 0;
          const statusLabel = budgetHours > 0
            ? 'Auto-matched by code'
            : mappedBudget
              ? `Matched to ${escapeHtml(mappedBudget)}`
              : 'Not matched yet';
          const isUnmatched = budgetHours === 0 && !mappedBudget;
          return `
            <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0.75rem; border: 1px dashed var(--border-color); border-radius: 6px; background: var(--background);">
              <div>
                <div style="font-family: monospace; font-weight: 600;">${escapeHtml(code)}</div>
                <div style="color: var(--text-secondary); font-size: 0.85rem;">${statusLabel}</div>
              </div>
              <span style="font-size: 0.8rem; color: ${isUnmatched ? 'var(--warning-color)' : 'var(--success-color)'}; background: ${isUnmatched ? 'rgba(234,179,8,0.12)' : 'var(--success-surface)'}; padding: 0.3rem 0.55rem; border-radius: 999px;">${isUnmatched ? 'Unmapped' : 'Mapped'}</span>
            </div>
          `;
        }).join('') || '<div class="empty-filter">No actual codes found.</div>';

        return `
          <div class="card" style="margin-bottom: 1.5rem; background-color: var(--background);">
            <div style="display: flex; justify-content: space-between; align-items: center; gap: 1rem; margin-bottom: 0.5rem; flex-wrap: wrap;">
              <h4 style="margin: 0;">${escapeHtml(projectName)}</h4>
              <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                <span class="chip" style="background: var(--card-background);">${sortedBudgetCodes.length} budget codes</span>
                <span class="chip" style="background: var(--card-background);">${sortedActualCodes.length} spent codes</span>
                <span class="chip" style="background: var(--success-surface); color: var(--success-color);">${matchedCount} matched</span>
                <span class="chip" style="background: rgba(234,179,8,0.12); color: var(--warning-color);">${unmatchedBudgetCodes.length} to match</span>
              </div>
            </div>

            <div style="display: grid; gap: 1rem; margin-top: 0.5rem;">
              <div>
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.35rem;">
                  <h5 style="font-size: 0.95rem; margin: 0;">Budgeted cost codes</h5>
                  <div style="color: var(--text-secondary); font-size: 0.85rem;">Select the matching actual code for each budget code.</div>
                </div>
                <div style="display: grid; gap: 0.6rem;">
                  ${budgetRows}
                </div>
              </div>

              <div>
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.35rem;">
                  <h5 style="font-size: 0.95rem; margin: 0;">Spent cost codes</h5>
                  <div style="color: var(--text-secondary); font-size: 0.85rem;">${unmatchedActualCodes.length} available to match.</div>
                </div>
                <div style="display: grid; gap: 0.5rem; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));">
                  ${actualRows}
                </div>
              </div>
            </div>
          </div>
        `;
      }).join('');
    }

    async function handleMappingSelect(projectId, encodedBudgetCode, actualCode) {
      const budgetCode = decodeURIComponent(encodedBudgetCode);

      try {
        if (!actualCode) {
          await deleteCodeMapping(projectId, budgetCode, { skipConfirm: true });
        } else {
          await saveCodeMapping(projectId, budgetCode, actualCode, { skipValidation: true, skipReset: true });
        }

        await loadCodeMappings();
        await loadComparison();
      } catch (error) {
        console.error('Error updating mapping:', error);
        alert('Error updating mapping. Please try again.');
      }
    }

    async function saveCodeMapping(projectId, budgetCodeOverride = null, actualCodeOverride = null, options = {}) {
      const budgetCodeSelect = document.getElementById(`budgetCode_${projectId}`);
      const actualCodeSelect = document.getElementById(`actualCode_${projectId}`);

      const budgetCode = budgetCodeOverride ?? budgetCodeSelect?.value ?? '';
      const actualCode = actualCodeOverride ?? actualCodeSelect?.value ?? '';

      if (!budgetCode || !actualCode) {
        if (!options.skipValidation) {
          alert('Please select both a budget code and an actual code');
        }
        return;
      }

      try {
        const response = await fetch(`/api/projects/${projectId}/code-mappings`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ budgetCode, actualCode })
        });

        if (!response.ok) {
          throw new Error('Failed to save mapping');
        }

        await loadCodeMappings();
        await loadComparison();

        if (!options.skipReset && budgetCodeSelect && actualCodeSelect) {
          budgetCodeSelect.value = '';
          actualCodeSelect.value = '';
        }
      } catch (error) {
        console.error('Error saving code mapping:', error);
        if (!options.skipValidation) {
          alert('Error saving mapping. Please try again.');
        }
      }
    }

    async function deleteCodeMapping(projectId, budgetCode, options = {}) {
      if (!options.skipConfirm && !confirm(`Delete mapping for budget code "${budgetCode}"?`)) {
        return;
      }

      try {
        const response = await fetch(`/api/projects/${projectId}/code-mappings/${encodeURIComponent(budgetCode)}`, {
          method: 'DELETE'
        });

        if (!response.ok) {
          throw new Error('Failed to delete mapping');
        }

        await loadCodeMappings();
        await loadComparison();
      } catch (error) {
        console.error('Error deleting code mapping:', error);
        if (!options.skipConfirm) {
          alert('Error deleting mapping. Please try again.');
        }
      }
    }

    // Close modal when clicking outside
    window.onclick = function(event) {
      const modal = document.getElementById('codeMappingModal');
      if (event.target === modal) {
        closeCodeMappingModal();
      }
    }
  </script>
</body>
</html>
